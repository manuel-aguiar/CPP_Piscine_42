# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    cpp09_ex02_notes.txt                               :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: manuel <manuel@student.42.fr>              +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/05/02 10:52:52 by codespace         #+#    #+#              #
#    Updated: 2024/05/03 09:52:31 by manuel           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

a template instantiate with two different classes will have their own
static variable instances, even though these do not depend on the
template types themselves:

#include <iostream>

template<typename T>
class MyClass {
    public:
        int* getprivate(void)
        {
            return (&staticVar);
        }
private:
    static int staticVar;
    T           cenas;
};

template<typename T>
int MyClass<T>::staticVar = 0;

int main() {
    // Instantiate the template with two different types
    MyClass<int> obj1;
    MyClass<float> obj2;
    MyClass<int> obj3;

    // Print the address of the static member variable for each instance
    std::cout << "Address of staticVar in obj1: " << obj1.getprivate() << std::endl;
    std::cout << "Address of staticVar in obj2: " << obj2.getprivate() << std::endl;
    std::cout << "Address of staticVar in obj3: " << obj3.getprivate() << std::endl;

    return 0;
}

obj3 gets the same as obj1 as the template instatiated is the same (type <int>)


**********************************************

Template overkill:


		#include <iostream>
		#include <vector>
		#include <list>
		#include <deque>
		#include <set>


		template <
			typename T = int,
			template <
				typename,
				typename
			> class Container = std::vector,
			typename Allocator = std::allocator<T>
		>
		class ContainerWrapper {
		public:
			// Constructor
			ContainerWrapper() {}

			// Member function to add elements
			void addElement(const T& element) {
				container.push_back(element); // Example operation on the container
			}

			void addPair(const T& first, const T& second)
			{
				pairs.push_back(std::make_pair(first, second));
			}


		private:
			Container<T, Allocator >                   container; // Container with provided traits
			Container<std::pair<T,T>, Allocator >     pairs;
		};


		template <
			typename T = int,
			template <
				typename,
				typename
			> class First = std::vector,
			template <
				typename,
				typename
			> class Second = std::deque
		>
		class Holder
		{
		private:
			ContainerWrapper<T, First> first;
			ContainerWrapper<T, Second> second;
		};


		int main()
		{
			Holder<int, std::vector, std::list> wtf;
			Holder<int, std::deque, std::list> cenas;

			Holder<std::vector<int>, std::vector, std::vector> crazy;

			Holder<> empty;

			(void)wtf;
			(void)cenas;
			(void)crazy;
			(void)empty;
			return 0;
		}


*******************************************