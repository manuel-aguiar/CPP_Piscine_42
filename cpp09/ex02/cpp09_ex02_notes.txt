# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    cpp09_ex02_notes.txt                               :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: codespace <codespace@student.42.fr>        +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/05/02 10:52:52 by codespace         #+#    #+#              #
#    Updated: 2024/05/02 11:00:43 by codespace        ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

a template instantiate with two different classes will have their own
static variable instances, even though these do not depend on the
template types themselves:

#include <iostream>

template<typename T>
class MyClass {
    public:
        int* getprivate(void)
        {
            return (&staticVar);
        }
private:
    static int staticVar;
    T           cenas;
};

template<typename T>
int MyClass<T>::staticVar = 0;

int main() {
    // Instantiate the template with two different types
    MyClass<int> obj1;
    MyClass<float> obj2;
    MyClass<int> obj3;

    // Print the address of the static member variable for each instance
    std::cout << "Address of staticVar in obj1: " << obj1.getprivate() << std::endl;
    std::cout << "Address of staticVar in obj2: " << obj2.getprivate() << std::endl;
    std::cout << "Address of staticVar in obj3: " << obj3.getprivate() << std::endl;

    return 0;
}

obj3 gets the same as obj1 as the template instatiated is the same (type <int>)


**********************************************
